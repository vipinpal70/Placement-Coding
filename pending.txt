
Searching & Sorting 

------>  Minimum number of swaps required to sort an array


Backtracking and DP

------> Partition Equal Subset Sum
------> M-Coloring Problem
------> Print all Palindromic Partitions of a String using Bit Manipulation
------> Partition of a set into K subsets with equal sum
------> Hamiltonian Cycle









------------------------------>

//Most effecient solution in O(1) time !
    int celebrity(int M[][], int n){
    	if(n==1){
    	    return -1;
    	}
    	Deque<Integer> s=new ArrayDeque<>();
    	for(int i=0;i<n;i++){
    	    s.push(i);
    	}
    	while(s.size()>1){
    	    int a=s.pop();
    	    int b=s.pop();
    	    if(M[a][b]==1){ // a knows b
    	        s.push(b);
    	    }
    	    else{ // b knows a
    	        s.push(a);
    	    }
    	}
    	int ans=s.peek(); // possible celebrity
    	for(int i=0;i<n;i++){ //checking if everybody knows him and if he knows anyone or not     
    	    if(M[ans][i]==1 || (M[i][ans]==0 && i!=ans)){
    	        return -1;
    	    }
    	}
    	return ans;
    }